# AGENT.md - Project Guide for AI Assistants

This document serves as the authoritative guide for AI agents working on the `tainiex-atlas` project. It outlines the architectural decisions, design patterns, and constraints that must be followed.

## 0. Principle
- You should detect the OS type before using any tools to ensure you use the correct one (PowerShell, Bash, Zsh, etc.).
- Save the plan file and all related data generated by the code agent to the .llm directory.
- **Strict Approval Workflow**:
  - **Code Changes**: ALWAYS ask for user confirmation before modifying code files (unless fixing a syntax error explicitly caused by the agent in the immediate previous step).
  - **Git Push**: NEVER push code to the remote repository without explicit user approval. "Pushing" is a separate, high-risk action that requires a distinct confirmation step.


## 1. Project Overview
- **Project Name**: `tainiex-atlas`
- **Description**: Backend service for the Tainiex platform, providing authentication, chat capabilities, and AI integration.
- **Framework**: NestJS (Node.js)
- **Language**: TypeScript (Target: ES2023)
- **Database**: PostgreSQL (via TypeORM)
- **Package Manager**: pnpm
- **Debug Directory**: Save all debug artifacts (scripts, logs, temp files) to the .llm directory.
- **Logging**: Unified Winston-based `LoggerService` for all application logging
  - **Format**: Development: colored console with PID (`[Nest] PID - Timestamp Level [Context] Message`); Production: JSON
  - **Configuration**: `LOG_LEVEL` environment variable (`debug` | `info` | `warn` | `error`)
  - **Global Registration**: Set in `src/main.ts` via `app.useLogger(customLogger)`
  - **Usage**: Inject `LoggerService` in constructors, call `this.logger.setContext(ClassName.name)`
  - **Exception**: `WebSocketExceptionFilter` uses NestJS Logger (filters can't use DI)


## 2. Architecture & Design

### 2.1. Code Map (代码地图)

This section serves as the **Index (Yellow Pages)** for the entire codebase.

#### **Directory Structure**

- **src/app.module.ts**: Root module, aggregates all feature modules.
- **src/main.ts**: Entry point, Global Pipes, View Engine, Swagger, and Logger setup.

#### **Feature Modules (功能模块)**

- **`src/auth/` (Authentication)**
    - `AuthService`: Handles Login, Registration, Password Hashing.
    - `strategies/`: Passport strategies (Local, Google, JWT, JWT-Refresh).
    - `guards/`: Global and local Auth Guards.
- **`src/chat/` (AI Chat System)**
    - `ChatGateway`: **WebSocket** entry point for AI streaming with detailed event handling.
    - `ChatService`: Manages session logic, message persistence, and LLM orchestration.
    - `queue/`: In-memory job queue for asynchronous tasks (e.g., backfill processing).
    - `memory/`: Integration with RAG/Memory services (semantic search, distillation).
    - `worker/`: **Generic Worker Pool** (Piscina) for CPU-intensive tasks.
- **`src/notes/` (Collaboration & Knowledge)**
    - `CollaborationGateway`: **WebSocket** entry for real-time Y.js sync.
    - `NotesService`: Note CRUD operations with tree structure support.
    - `BlocksService`: CRUD for atomic note blocks.
    - `YjsTransformer`: Service to convert between DB state and Y.js binary state.
    - `PresenceService`: Manages real-time cursor and user presence.
    - `VersionsService`: Handles block versioning and snapshots.
- **`src/llm/` (AI Integration)**
    - `LlmService`: Wrapper for Google Vertex AI SDK and Mistral AI.
    - `adapters/`: Model adapters for different provider interfaces (Gemini, Mistral).
- **`src/tools/` (Agentic AI Tools)**
    - `ToolsService`: Tool registry and execution manager.
    - `providers/`: Concrete tool implementations (WeatherTool, SearchTool, WikipediaTool, StockTool).
- **`src/graph/` (Knowledge Graph - Graph RAG)**
    - `GraphService`: Knowledge graph CRUD and traversal (Recursive CTE).
    - `entities/`: GraphNode, GraphEdge.
- **`src/users/`**: User entity and profile management.
- **`src/invitation/`**: Logic for invitation code generation/validation.
- **`src/rate-limit/`**: Distributed rate limiting (PostgreSQL-backed with in-memory cache).
- **`src/health/`**: Health check endpoints (Liveness/Readiness probes).

#### **Core & Shared (核心与共享)**

- **`src/common/`**
    - `activity/`: **Real-time Activity Tracking**
        - `ActivityGateway`: WebSocket gateway for broadcasting agent activities.
        - `ActivityPublisher`: Pub/sub service for publishing activity events.
        - `@TrackActivity` decorator: Automatic tracking for service methods.
    - `logger/`: **Centralized Logging**
        - `LoggerService`: Winston-based logger with environment-specific formatting.
        - Dev: Colored console with PID. Prod: JSON format.
    - `storage/`: **Google Cloud Storage Integration**
        - `StorageService`: File upload, signed URL generation.
    - `websocket/`: **WebSocket Utilities**
        - `WebSocketStateMachineService`: XState-based connection state management.
        - Error handling and reliable messaging utilities.
    - `context/`: **Request Context (CLS)**
        - `ClsService`: Continuation Local Storage for request tracing.
    - `filters/`: Global Exception Filters (e.g., `AllExceptionsFilter`, `WebSocketExceptionFilter`).
    - `guards/`: RateLimitGuard, etc.
- **`shared-atlas/` (External Shared Lib)**
    - Contains strictly typed **DTOs** and **Interfaces** shared with the Frontend (Flutter/Web/Rust).
    - `src/dto/`: Request/Response objects.
    - `src/interfaces/`: Core entity types (IUser, etc.).
    - `script/`: Code generation tools (Dart, Rust).

#### **Infrastructure & Scripts**

- **`script/`**
    - `create_schema.sql`: Source of Truth for Database Schema.
- **`shared-atlas/script/`**
    - `generate-dart.ts`: Dart DTO code generation for Flutter.
    - `generate-rust.ts`: Rust struct generation for native/WASM.

---

### 2.2. Document Index (文档索引)

The `docs/` directory contains detailed architectural designs. **Always check these before significant refactoring.**

| ID | Filename | Description (ZH/EN) |
|---|---|---|
| 001 | [arch-design-001-websocket-state-machine.md](docs/arch-design-001-websocket-state-machine.md) | WebSocket State Management Design / WebSocket 状态机设计 |
| ... | ... | *Add new design docs here* |

### 2.2. Database (TypeORM)
- **Entities**: All entities are defined in their respective modules/directories.
- **Naming Convention**:
    - **Class Properties**: `camelCase` (e.g., `createdAt`)
    - **Database Columns**: `snake_case` (e.g., `created_at`)
    - **Constraint**: Always use `@Column({ name: 'snake_case_name' })` to map properties.
- **Sync**: `synchronize: true` is currently enabled for development auto-migration.
- **Schema Script**: `script/create_schema.sql` serves as the reference for the "fresh" database state and seed data.
  - **Seeding**: 100 codes are auto-generated via SQL `generate_series` in `create_schema.sql`.
- **Notes System Optimization**:
    - **Smart Snapshots**: Note snapshots are created only when `updated_at` changes, managed by a daily cron job.
    - **CRDT Persistence**: Y.js binary state is persisted in `document_states` table for disaster recovery.
    - **Versioning**: Uses a hybrid approach with full snapshots every 10 updates and diffs for intermediate versions.
    - **Tree Performance**: Uses **Partial Indexes** (`WHERE is_deleted = FALSE`) to optimize hierarchical queries. Specifically, `idx_notes_parent_active` ensures efficient lazy loading of the note tree.
- Avoid using foreign keys; it's considered bad practice. Constraints should be handled in the code.
  - If entity schemas are used for frontend responses, they must reside in a shared library. 
- **Required PostgreSQL Extensions**:
  - **`tsvector`**: PostgreSQL built-in full-text search (no installation required)
  - **`pgvector`**: Vector similarity search for AI embeddings and semantic search
  - **Installation**: Run `CREATE EXTENSION IF NOT EXISTS vector;` at database initialization
  - **Verification**: Run `SELECT * FROM pg_extension WHERE extname = 'vector';`
  - **Notes**: Both extensions should be enabled in `script/create_schema.sql` before table creation 

### 2.3. Authentication Flow
- **Strategy**: JWT Pair (Access Token + Refresh Token).
- **Tokens**:
    - `access_token`: Short-lived (15m).
    - `refresh_token`: Long-lived (7d), hashed and stored in DB (`hashed_refresh_token`).
- **WebSocket Authentication**: 
    - Supports both manual `auth.token` and browser-based `httpOnly` cookies (`access_token`).
    - The gateway parses the `Cookie` header from the handshake if no token is provided in `auth`.
- **Google OAuth**:
    - **Login**: `POST /auth/google` with `{ code }`.
    - **New User Flow**:
        1. If user doesn't exist, backend returns `{ requiresInvite: true, signupToken: "..." }`.
        2. **Security**: We do NOT return the raw Google ID Token. We issue a temporary, backend-signed `signupToken` containing the user's profile info.
        2. **Security**: We do NOT return the raw Google ID Token. We issue a temporary, backend-signed `signupToken` containing the user's profile info.
        3. Client submits `signupToken` + `invitationCode` to `POST /auth/google/signup` to finalize creation.
        2. **Security**: We do NOT return the raw Google ID Token. We issue a temporary, backend-signed `signupToken` containing the user's profile info.
        3. Client submits `signupToken` + `invitationCode` to `POST /auth/google/signup` to finalize creation.
    - **Token Lifecycle / 令牌生命周期**:
        - **Proactive Notification / 主动通知**: Server monitors token expiry (via `TokenLifecycleService`) and emits `auth:token-expiring` 5 minutes before expiration.
        - 服务器监控令牌过期（通过 `TokenLifecycleService`），在过期前 5 分钟发送 `auth:token-expiring`。
        - **Renewal / 续期**: Client must call `POST /auth/refresh`, then emit `auth:token-refreshed` with the new token to reset the server-side timer without reconnecting.
        - 客户端必须调用 `POST /auth/refresh`，然后发送 `auth:token-refreshed` 携带新令牌，以重置服务器端计时器且无需重连。

### 2.4. WebSocket Architecture
- **Single Connection Strategy**: The application accepts a single physical WebSocket connection (Socket.IO `Manager`) multiplexed into different namespaces. This is the recommended client-side implementation to conserve resources.
- **Namespaces**:
    - **`/api/chat`**: Handles AI chat sessions, message sending, and streaming.
    - **`/api/collaboration`**: Handles real-time note editing (Y.js sync) and presence updates.
    - **`/api/activity`**: Broadcasts real-time agent activity events (THINKING, TOOL_EXECUTION, etc.).
- **Client Implementation**: 
    - Clients should instantiate **one** `Manager` with the root URL and authentication options.
    - Open discrete sockets for distinct namespaces from the same manager: `manager.socket('/api/chat')`, `manager.socket('/api/collaboration')`, and `manager.socket('/api/activity')`.
- **Authentication**: All namespaces share the same authentication mechanism (JWT in `auth.token` or `cookie`).
- **Reliability (ACK System) / 可靠性（ACK 系统）**:
    - Critical messages (e.g., stream start, state sync) are sent via `ReliableMessageService` with a `messageId`.
    - 关键消息（如流开始、状态同步）通过 `ReliableMessageService` 发送，包含 `messageId`。
    - Clients MUST acknowledge these messages via `message:ack` `{ messageId }`.
    - 客户端必须通过 `message:ack` `{ messageId }` 确认这些消息。
    - Server automatically resends unacknowledged messages upon user reconnection.
    - 用户重连时，服务器会自动重发未确认的消息。
- **Error Handling / 错误处理**:
    - All WebSocket errors follow a strict JSON structure: `{ code, message, category, details, timestamp }`.
    - 所有 WebSocket 错误遵循严格的 JSON 结构。
    - See `WebSocketErrorCode` enum for specific codes (40xx Auth, 42xx Validation, 50xx Server).
    - 具体代码请参考 `WebSocketErrorCode` 枚举。
- **Connection Health**:
    - `ConnectionHealthService` monitors ping latency and assigns health scores.
    - Low health scores (\u003c40) trigger warnings to encourage client reconnection.
    - Configured with optimized `pingInterval` (10s) and `pingTimeout` (20s) for mobile stability.

### 2.5. State Machine Architecture / 状态机架构

- **Library**: XState (v5.x) for managing complex state transitions
- **库**: XState (v5.x) 用于管理复杂状态转换
- **Primary Usage**: WebSocket connection lifecycle, authentication flows, collaboration session states
- **主要用途**: WebSocket 连接生命周期、身份验证流程、协作会话状态
- **Location**: `src/common/websocket/websocket-state-machine.service.ts`
- **Benefits**:
    - **Visualization**: XState visualizer for debugging state flows / 使用 XState 可视化工具调试状态流转
    - **Type Safety**: Full TypeScript inference for states and events / 完整的 TypeScript 类型推断（状态和事件）
    - **Testability**: Machine snapshots for deterministic testing / 通过状态机快照实现确定性测试
- **Documentation**: See `docs/arch-design-001-websocket-state-machine.md` for detailed design
- **文档**: 参见 `docs/arch-design-001-websocket-state-machine.md` 了解详细设计

## 3. Key Feature Specifications

### 3.1. Invitation System
- **Mandatory**: New registrations (Email or Google) MUST provide a valid invitation code.
- **Implementation**: `InvitationService` checks code validity, expiry, and usage status.
- **Storage**: `invitation_code` table. Foreign keys to User are NOT used; `usedByUserId` is stored as a raw UUID string.
- **Seeding**: 100 codes are auto-generated via SQL `generate_series` in `create_schema.sql`.

### 3.2. Chat System
- **Sessions**: Stored in `chat_sessions`. Contains a `title` and link to `User`.
- **Messages**: Stored in `chat_messages`. Linked to `ChatSession`.
- **Real-time Streaming**: Implemented via `ChatGateway` using Socket.io. Supports character-by-character streaming to bypass Cloud Run/Proxy buffering.
- **Real-time Streaming**: Implemented via `ChatGateway` using Socket.io. Supports character-by-character streaming to bypass Cloud Run/Proxy buffering.
- **Connection Stability**: Configured with optimized `pingInterval` (10s) and `pingTimeout` (20s) to handle mobile network jitters.
- **Health Monitoring**: `ConnectionHealthService` tracks ping latency. Health scores < 40 trigger warnings (but do not disconnect automatically).
- **Auto-Title**: Upon the **first message** of a session, the system calls `LlmService` to generate a summary title (< 15 chars) and updates the session title.
- **Auto-Title**: Upon the **first message** of a session, the system calls `LlmService` to generate a summary title (< 15 chars) and updates the session title.
- **Message Versioning**: Implemented via `chat_message_histories`. Before updating a message, its current state is archived.
- **Linked-List Structure**: `chat_messages` use `parent_id` (default 'ROOT') to track sequential relationships and version paths.
- **Token Window Management**: `TokenWindowManager` manages context windowing to ensure conversations stay within LLM token limits while preserving critical context.

### 3.4. Global JWT Configuration
- **Standardization**: `JwtModule` is registered as a **global module** in `AuthModule` via `registerAsync`.
- **Consistency**: All feature modules (like `ChatModule`) must NOT re-register `JwtModule` to ensure they use the same Secret Key and Service instance.

### 3.3. LLM Integration
- **Providers**: Google Vertex AI (Gemini Models), Mistral AI, and OpenRouter.
- **Service**: `LlmService` handles API calls to providers. Uses `LlmAdapterFactory` to select the correct adapter based on model name.
- **Configuration**:
    - Vertex AI: Credentials loaded via `GSA_KEY_FILE` or explicit Project/Location env vars.
    - Mistral AI: Requires `MISTRAL_API_KEY` in environment variables.
    - OpenRouter: Requires `OPENROUTER_API_KEY` in environment variables.

### 3.3.1. Agent Engine - Streaming Optimization (流式输出优化)
- **Component**: `ReactAgentEngine` (`src/agent-core/react-engine.ts`)
- **Challenge**: Balancing tool call detection with real-time streaming UX
  - 挑战：在工具调用检测和实时流式体验之间取得平衡
- **Previous Approach (旧方案)**:
  - Buffer entire LLM response → Detect tool calls → Output to user
  - 缓冲完整的 LLM 响应 → 检测工具调用 → 输出给用户
  - **Problem**: High latency (30-50s for long responses from slow providers)
  - 问题：延迟高（慢速提供商的长响应需要 30-50 秒）
- **Current Approach (当前方案) - Stream-First Detection**:
  ```typescript
  // 1. Check first chunk
  if (firstChunk.startsWith('{')) {
    // Native function calling (JSON) → Buffer mode
    // 原生函数调用（JSON）→ 缓冲模式
    hasToolCall = true;
  } else {
    // Text response → Stream immediately
    // 文本响应 → 立即流式输出
    yield { type: 'answer_chunk', content: chunk };
  }

  // 2. Subsequent chunks
  if (hasToolCall) {
    continue; // Keep buffering
  } else {
    yield { type: 'answer_chunk', content: chunk }; // Stream directly
  }
  ```
- **Advantages (优势)**:
  - **Zero latency for text responses**: Streams start immediately when first chunk arrives
    - 文本响应零延迟：第一个 chunk 到达时立即开始流式输出
  - **Native function calling support**: Google Vertex AI and compatible providers return JSON in first chunk
    - 原生函数调用支持：Google Vertex AI 等兼容提供商在第一个 chunk 返回 JSON
  - **Backward compatible**: Still supports text-based tool call parsing (though buffered)
    - 向后兼容：仍支持基于文本的工具调用解析（虽然会缓冲）
- **Performance Improvement (性能提升)**:
  - Before: 741 chunks → 34s buffering → 25 large chunks → User sees response
    - 之前：741 个 chunks → 34 秒缓冲 → 25 个大块 → 用户看到响应
  - After: 741 chunks → Each chunk streams immediately → <1s first token
    - 之后：741 个 chunks → 每个 chunk 立即流式输出 → <1 秒首个 token
- **Reference**: Inspired by OpenAI and Claude Code's stream-first approach
  - 参考：借鉴了 OpenAI 和 Claude Code 的流式优先方法

### 3.5. Notes & Collaboration System
- **Block-Based Storage**: Notes are composed of multimodal blocks (TEXT, HEADING, IMAGE, etc.).
- **Tree Structure (Lazy Loading)**:
    - `GET /api/notes` without `parentId` parameter returns **only root notes** (where `parentId = null`).
    - `GET /api/notes?parentId={id}` returns children of the specified parent.
    - Each note includes `hasChildren: boolean` to indicate if it has sub-notes (for UI rendering).
    - This design prevents loading thousands of notes at once and supports efficient tree navigation.
- **Concurrency Control**: Limited to **5 concurrent users** per note to ensure stability in a single-instance architecture. Managed by `PresenceService`.
- **Real-time Sync**: Implemented via `CollaborationGateway` and **Y.js (CRDT)**.
    - **Binary Updates**: Y.js updates are transmitted as base64-encoded strings over WebSockets.
    - **Presence**: Cursor positions and selection ranges are synchronized in real-time.
    - **Integration Flow**:
        1. Client connects via WebSocket (`/api/collaboration`).
        2. Client MUST emit `note:join` `{ noteId }` to subscribe.
        3. Server responds with `yjs:sync` containing initial state (blocks).
        4. Client binds Tiptap to `blocks` key.
- **File Management**: Integrated with `StorageService` for GCS uploads. Supports images (10MB), videos (100MB), and attachments (50MB) with signed URLs.

### 3.6. Rate Limiting
- **Strategy**: Distributed Rate Limiting via PostgreSQL (Atomic Upsert).
- **Storage**: `rate_limits` table.
- **Optimization**: Uses in-memory `blockedCache` to reject repetitive spam without hitting DB when a user is already blocked.
- **Storage**: `rate_limits` table.
- **Storage**: `rate_limits` table.
- **Optimization**: Uses in-memory `blockedCache` to reject repetitive spam without hitting DB when a user is already blocked.
- **Blocklist / 黑名单**: Automatic 1-hour IP block if > 200 requests/hour (in-memory enforcement via `RateLimitService`).
- 超过 200 请求/小时自动封锁 IP 1 小时（通过 `RateLimitService` 在内存中执行）。
- **Implementation**: `RateLimitService` uses raw SQL for atomic operations to handle concurrency correctly.

## 4. Constraints & Conventions
1.  **Code Style**: Follow standard Prettier/ESLint rules.
2.  **DTOs/Interfaces**: 
    - **Shared Library**: Define shared interfaces/DTOs in `@tainiex/shared-atlas` for all API request/response bodies.
    - **Strict Validation**: Controllers MUST use DTOs decorated with `class-validator` (e.g., `@Body() dto: SignupDto`).
    - **Forbidden**: usage of `any` or raw objects like `@Body() req` in controllers is **STRICTLY FORBIDDEN**.
    - **Global Pipe**: The application runs with a global `ValidationPipe({ whitelist: true })`. Properties not in the DTO will be stripped.
3.  **Environment Variables**: All sensitive config (DB creds, API keys) must come from `ConfigService`.
4.  **WebSocket CORS**: Uses a dynamic origin function in `ChatGateway` that strictly verifies the origin against `CORS_ORIGIN` env var to support `credentials: true`.
5.  **No Direct SQL**: Prefer TypeORM repositories for data access, unless performing bulk seed/maintenance operations in scripts.
    - When modifying DB schema, always update **both** the Entity file AND `script/create_schema.sql`.
    - When adding new modules, remember to register them in `AppModule`.
    - **Separation of Concerns**: Keep `ChatModule` (Domain/Stateful) and `LlmModule` (Infrastructure/Stateless) separate. `Chat` consumes `Llm`.
    - **LLM Interaction Constraint**: Direct LLM chat interaction is forbidden. All chat interactions MUST be scoped to a `ChatSession` and managed via `ChatModule`.
6.  **Security**:
    -   **CORS**: NEVER use dynamic callbacks that reflect the origin (`callback(null, true)`). Always check against `CORS_ORIGIN`.
    -   **Race Conditions**: Use atomic database operations (e.g., `update` with `where`) for state transitions like claiming codes.
7.  **Testing**:
    -   All business logic (Services/Gateways) MUST have unit tests (`.spec.ts`).
    -   Use `jest` for testing.

## 5. Development Workflow
- **Start Dev**: `yarn run start:dev`
- **Reset DB**: Use `script/create_schema.sql` (can be run via `node script/reset_db.js` if available, or manual SQL execution).
- **Generate Client**: `pnpm run generate:dart` (Runs generation + verification).
- **Publish Client**: `cd shared-atlas-dart && dart pub publish`.

## 6. Memory Distillation System (New)

### 6.1. Concept
To provide long-term memory for the AI, we implement a "Memory Distillation" process. This system extracts atomic facts from conversations and notes, stores them as vector embeddings, and retrieves relevant memories for future interactions.

### 6.2. Architecture
- **Storage**: `semantic_memories` table (PostgreSQL + `pgvector`).
    - **No Foreign Keys**: `source_id` is a UUID, `user_id` is a UUID.
    - **Classification**: Memories are classified as `PERSONAL`, `DOMAIN`, or `TASK`.
    - **Provenance**: `source_type` (`CHAT` | `NOTE`) tracks where the memory came from.
- **Service**: `MemoryService` handles:
    - **Distillation**: Extracting facts via LLM (Analyst Persona).
    - **Deduplication**: Checking against existing vector embeddings before insertion.
    - **Retrieval**: Hybrid search (Vector + Keyword) for RAG.
- **Integration**:
    - **Chat**: `ChatService` retrieves relevant memories during `streamMessage` and injects them into the system prompt.
    - **LLM**: `LlmService` provides `getEmbeddings` (defaulting to `text-embedding-004`).

### 6.3. Distillation Workflow (Planned)
1.  **Trigger**: Topic Shift or Session End.
2.  **Extraction**: LLM identifies "Agreed Facts" vs "Transient Noise".
3.  **Storage**: Facts are stored with an evolving `importance` score.
3.  **Storage**: Facts are stored with an evolving `importance` score.
4.  **Consolidation**: Contradictory new facts update/archive old facts.

### 6.4. Historical Memory Backfill (Auto-Trigger)
-   **Purpose**: Automatically generate memories for old sessions that predate the distillation system.
-   **Mechanism**:
    -   **Trigger**: When a user loads a chat session (`GET /messages`), the system checks metadata.
    -   **Zero-Cost Check**: If `metadata.backfill_complete` is NOT true, a background job is enqueued.
    -   **Worker**: `InMemoryJobQueue` processes the backfill in chunks (20 messages) recursively.
    -   **Checkpointing**: Saves `last_backfilled_message_id` to DB to support crash recovery and idempotency.
    -   **Completion**: Once caught up, `backfill_complete` is set to `true`, preventing future overhead.

### 6.5. Retrieval Pipeline (检索流程)
1.  **Query Analysis**: Analyze user intent.
    -   **意图分析**: 分析用户查询的意图。
2.  **Hybrid Search**: Combine `pgvector` HNSW search with keyword matching.
    -   **混合搜索**: 结合 `pgvector` 的 HNSW 向量搜索与关键词匹配。
3.  **Adaptive Ranking (自适应排序)**: 
    -   **Concept**: Re-ranks candidates based on multiple factors.
    -   **理念**: 基于多重因子对召回的候选集进行重排序。
    -   **Formula (公式)**:
        `FinalScore = (Similarity * 0.7) + (Importance * 0.2) + (Recency * 0.1)`
    -   **Components (分量)**:
        -   **Similarity (相似度)**: Cosine similarity of embeddings.
            -   **余弦相似度**: 向量的点积与模长之比。
            -   **Vector Origins (向量来源)**:
                -   **Vector A (Query)**: Generated in real-time from user input via `llm.getEmbeddings(query)`.
                -   **Vector B (Memory)**: Retrieving from DB `embedding` column (generated at creation time).
            -   **Calculation (计算公式)**: `(A . B) / (||A|| * ||B||)`
        -   **Importance (重要性)**: Normalized score (1-3 → 0.33-1.0).
            -   **归一化重要性**: 将 1-3 分映射到 0.33-1.0 区间。
            -   **Source (来源)**: Generated by LLM during `distillConversation` based on information value (Critical/Valuable/Ordinary).
        -   **Recency (时效性)**: Time decay function `1 / (1 + 0.1 * days)`.
            -   **时间衰减**: 随时间推移降低权重，优先展示近期记忆。

### 6.6. Graph RAG Architecture (Personalized Knowledge Graph)
- **Purpose**: To model entities (Concepts, Projects, Tech) and their relationships, enabling mutli-hop reasoning.
- **Schema**:
    - **`graph_nodes`**: Stores entities with `embedding` (for semantic deduplication) and `type`.
    - **`graph_edges`**: Stores relationships (`source` -> `relation` -> `target`) with weights.
- **Process**:
    1. **Extraction**: `WorkerPoolService` dispatches task to `distillation.processor.ts`, where LLM extracts Entities & Relations.
    2. **Ingestion**: Processor directly connects to DB to Upsert Nodes and Create Edges (idempotent).
    3. **Traversal**: `GraphService` uses **Recursive CTE** (up to 3 hops) to find relevant paths during simple retrieval.
- **Threading Model**:
    -   **Generic Worker Pool**:
        -   **Service**: `WorkerPoolService` wraps `Piscina` for robust concurrency.
        -   **Dispatcher**: `main.worker.ts` routes tasks.
        -   **Processor**: `distillation.processor.ts` contains pure business logic (no worker deps).
    -   **Extraction & Ingestion**: Running strictly in **Worker Threads**.
        -   **Why**: Prevent Node.js Event Loop blocking during heavy graph processing or bulk DB writes.
        -   **Mechanism**: Main thread sends `DB_CONFIG`; Processor initializes independent `DataSource`.
    -   **Retrieval**: Running in **Main Thread** (fast read queries).
