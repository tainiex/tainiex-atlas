# AGENT.md - Project Guide for AI Assistants

This document serves as the authoritative guide for AI agents working on the `tainiex-atlas` project. It outlines the architectural decisions, design patterns, and constraints that must be followed.

## 0. Principle
- You should detect the OS type before using any tools to ensure you use the correct one (PowerShell, Bash, Zsh, etc.).
- Save the plan file and all related data generated by the code agent to the .llm directory.
- **Strict Approval Workflow**:
  - **Code Changes**: ALWAYS ask for user confirmation before modifying code files (unless fixing a syntax error explicitly caused by the agent in the immediate previous step).
  - **Git Push**: NEVER push code to the remote repository without explicit user approval. "Pushing" is a separate, high-risk action that requires a distinct confirmation step.


## 1. Project Overview
- **Project Name**: `tainiex-atlas`
- **Description**: Backend service for the Tainiex platform, providing authentication, chat capabilities, and AI integration.
- **Framework**: NestJS (Node.js)
- **Language**: TypeScript (Target: ES2023)
- **Database**: PostgreSQL (via TypeORM)
- **Package Manager**: pnpm
- **Debug Directory**: Save all debug artifacts (scripts, logs, temp files) to the .llm directory.
- **Logging**:
  - **NestJS Built-in Logger**: Controlled by `NODE_ENV` environment variable
    - `production`: Only outputs `error` and `warn` logs
    - `development`: Outputs all logs (`log`, `error`, `warn`, `debug`, `verbose`)
  - **Custom LoggerService**: Controlled by `LOG_LEVEL` environment variable (`debug` | `info` | `warn` | `error`)
  - **Configuration**: Set in `src/main.ts` during application bootstrap


## 2. Architecture & Design

### 2.1. Modular Structure
The application follows a modular architecture. Each major feature has its own directory in `src/` containing its Module, Controller, Service, and Entities.

- **`src/app.module.ts`**: Root module, aggregates all feature modules.
- **`src/auth/`**: Authentication logic (Local & Google OAuth).
- **`src/users/`**: User management and persistence.
- **src/chat/**: Chat sessions, message history, conversation logic, and **WebSocket Gateway**.
- **src/notes/**: Core notes system, block-level storage, templates, and **Collaboration Gateway**.
- **src/llm/**: Integration with Google Vertex AI (Gemini).
- **`src/invitation/`**: Invitation code generation and validation system.
- **`shared-atlas/`**: Shared interfaces and DTOs (e.g., `IUser`).
  - Request parameter structs (DTOs)
  - Response structs
  - Common shared structs
  - Keep the API type definitions shared
  - The shared library must contain more comments for users

### 2.2. Database (TypeORM)
- **Entities**: All entities are defined in their respective modules/directories.
- **Naming Convention**:
    - **Class Properties**: `camelCase` (e.g., `createdAt`)
    - **Database Columns**: `snake_case` (e.g., `created_at`)
    - **Constraint**: Always use `@Column({ name: 'snake_case_name' })` to map properties.
- **Sync**: `synchronize: true` is currently enabled for development auto-migration.
- **Schema Script**: `script/create_schema.sql` serves as the reference for the "fresh" database state and seed data.
  - **Seeding**: 100 codes are auto-generated via SQL `generate_series` in `create_schema.sql`.
- **Notes System Optimization**:
    - **Smart Snapshots**: Note snapshots are created only when `updated_at` changes, managed by a daily cron job.
    - **CRDT Persistence**: Y.js binary state is persisted in `document_states` table for disaster recovery.
    - **Versioning**: Uses a hybrid approach with full snapshots every 10 updates and diffs for intermediate versions.
    - **Tree Performance**: Uses **Partial Indexes** (`WHERE is_deleted = FALSE`) to optimize hierarchical queries. Specifically, `idx_notes_parent_active` ensures efficient lazy loading of the note tree.
- Avoid using foreign keys; it's considered bad practice. Constraints should be handled in the code.
  - If entity schemas are used for frontend responses, they must reside in a shared library. 
- **Required PostgreSQL Extensions**:
  - **`tsvector`**: PostgreSQL built-in full-text search (no installation required)
  - **`pgvector`**: Vector similarity search for AI embeddings and semantic search
  - **Installation**: Run `CREATE EXTENSION IF NOT EXISTS vector;` at database initialization
  - **Verification**: Run `SELECT * FROM pg_extension WHERE extname = 'vector';`
  - **Notes**: Both extensions should be enabled in `script/create_schema.sql` before table creation 

### 2.3. Authentication Flow
- **Strategy**: JWT Pair (Access Token + Refresh Token).
- **Tokens**:
    - `access_token`: Short-lived (15m).
    - `refresh_token`: Long-lived (7d), hashed and stored in DB (`hashed_refresh_token`).
- **WebSocket Authentication**: 
    - Supports both manual `auth.token` and browser-based `httpOnly` cookies (`access_token`).
    - The gateway parses the `Cookie` header from the handshake if no token is provided in `auth`.
- **Google OAuth**:
    - **Login**: `POST /auth/google` with `{ code }`.
    - **New User Flow**:
        1. If user doesn't exist, backend returns `{ requiresInvite: true, signupToken: "..." }`.
        2. **Security**: We do NOT return the raw Google ID Token. We issue a temporary, backend-signed `signupToken` containing the user's profile info.
        3. Client submits `signupToken` + `invitationCode` to `POST /auth/google/signup` to finalize creation.

### 2.4. WebSocket Architecture
- **Single Connection Strategy**: The application accepts a single physical WebSocket connection (Socket.IO `Manager`) multiplexed into different namespaces. This is the recommended client-side implementation to conserve resources.
- **Namespaces**:
    - **`/api/chat`**: Handles AI chat sessions, message sending, and streaming.
    - **`/api/collaboration`**: Handles real-time note editing (Y.js sync) and presence updates.
- **Client Implementation**: 
    - Clients should instantiate **one** `Manager` with the root URL and authentication options.
    - Open discrete sockets for distinct namespaces from the same manager: `manager.socket('/api/chat')` and `manager.socket('/api/collaboration')`.
- **Authentication**: Both namespaces share the same authentication mechanism (JWT in `auth.token` or `cookie`).

## 3. Key Feature Specifications

### 3.1. Invitation System
- **Mandatory**: New registrations (Email or Google) MUST provide a valid invitation code.
- **Implementation**: `InvitationService` checks code validity, expiry, and usage status.
- **Storage**: `invitation_code` table. Foreign keys to User are NOT used; `usedByUserId` is stored as a raw UUID string.
- **Seeding**: 100 codes are auto-generated via SQL `generate_series` in `create_schema.sql`.

### 3.2. Chat System
- **Sessions**: Stored in `chat_sessions`. Contains a `title` and link to `User`.
- **Messages**: Stored in `chat_messages`. Linked to `ChatSession`.
- **Real-time Streaming**: Implemented via `ChatGateway` using Socket.io. Supports character-by-character streaming to bypass Cloud Run/Proxy buffering.
- **Connection Stability**: Configured with optimized `pingInterval` (10s) and `pingTimeout` (20s) to handle mobile network jitters.
- **Auto-Title**: Upon the **first message** of a session, the system calls `LlmService` to generate a summary title (< 15 chars) and updates the session title.
- **Message Versioning**: Implemented via `chat_message_histories`. Before updating a message, its current state is archived.
- **Linked-List Structure**: `chat_messages` use `parent_id` (default 'ROOT') to track sequential relationships and version paths.
- **Token Window Management**: `TokenWindowManager` manages context windowing to ensure conversations stay within LLM token limits while preserving critical context.

### 3.4. Global JWT Configuration
- **Standardization**: `JwtModule` is registered as a **global module** in `AuthModule` via `registerAsync`.
- **Consistency**: All feature modules (like `ChatModule`) must NOT re-register `JwtModule` to ensure they use the same Secret Key and Service instance.

### 3.3. LLM Integration
- **Provider**: Google Vertex AI (Gemini Models).
- **Service**: `LlmService` handles API calls to Vertex AI (both standard `generateContent` and streaming `streamChat`).
- **Configuration**: Credentials loaded via `GSA_KEY_FILE` or explicit Project/Location env vars.

### 3.5. Notes & Collaboration System
- **Block-Based Storage**: Notes are composed of multimodal blocks (TEXT, HEADING, IMAGE, etc.).
- **Tree Structure (Lazy Loading)**:
    - `GET /api/notes` without `parentId` parameter returns **only root notes** (where `parentId = null`).
    - `GET /api/notes?parentId={id}` returns children of the specified parent.
    - Each note includes `hasChildren: boolean` to indicate if it has sub-notes (for UI rendering).
    - This design prevents loading thousands of notes at once and supports efficient tree navigation.
- **Concurrency Control**: Limited to **5 concurrent users** per note to ensure stability in a single-instance architecture. Managed by `PresenceService`.
- **Real-time Sync**: Implemented via `CollaborationGateway` and **Y.js (CRDT)**.
    - **Binary Updates**: Y.js updates are transmitted as base64-encoded strings over WebSockets.
    - **Presence**: Cursor positions and selection ranges are synchronized in real-time.
    - **Integration Flow**:
        1. Client connects via WebSocket (`/api/collaboration`).
        2. Client MUST emit `note:join` `{ noteId }` to subscribe.
        3. Server responds with `yjs:sync` containing initial state (blocks).
        4. Client binds Tiptap to `blocks` key.
- **File Management**: Integrated with `StorageService` for GCS uploads. Supports images (10MB), videos (100MB), and attachments (50MB) with signed URLs.

### 3.6. Rate Limiting
- **Strategy**: Distributed Rate Limiting via PostgreSQL (Atomic Upsert).
- **Storage**: `rate_limits` table.
- **Optimization**: Uses in-memory `blockedCache` to reject repetitive spam without hitting DB when a user is already blocked.
- **Implementation**: `RateLimitService` uses raw SQL for atomic operations to handle concurrency correctly.

## 4. Constraints & Conventions
1.  **Code Style**: Follow standard Prettier/ESLint rules.
2.  **DTOs/Interfaces**: 
    - **Shared Library**: Define shared interfaces/DTOs in `shared-lib` for all API request/response bodies.
    - **Strict Validation**: Controllers MUST use DTOs decorated with `class-validator` (e.g., `@Body() dto: SignupDto`).
    - **Forbidden**: usage of `any` or raw objects like `@Body() req` in controllers is **STRICTLY FORBIDDEN**.
    - **Global Pipe**: The application runs with a global `ValidationPipe({ whitelist: true })`. Properties not in the DTO will be stripped.
3.  **Environment Variables**: All sensitive config (DB creds, API keys) must come from `ConfigService`.
4.  **WebSocket CORS**: Uses a dynamic origin function in `ChatGateway` that strictly verifies the origin against `CORS_ORIGIN` env var to support `credentials: true`.
5.  **No Direct SQL**: Prefer TypeORM repositories for data access, unless performing bulk seed/maintenance operations in scripts.
    - When modifying DB schema, always update **both** the Entity file AND `script/create_schema.sql`.
    - When adding new modules, remember to register them in `AppModule`.
    - **Separation of Concerns**: Keep `ChatModule` (Domain/Stateful) and `LlmModule` (Infrastructure/Stateless) separate. `Chat` consumes `Llm`.
    - **LLM Interaction Constraint**: Direct LLM chat interaction is forbidden. All chat interactions MUST be scoped to a `ChatSession` and managed via `ChatModule`.
6.  **Security**:
    -   **CORS**: NEVER use dynamic callbacks that reflect the origin (`callback(null, true)`). Always check against `CORS_ORIGIN`.
    -   **Race Conditions**: Use atomic database operations (e.g., `update` with `where`) for state transitions like claiming codes.
7.  **Testing**:
    -   All business logic (Services/Gateways) MUST have unit tests (`.spec.ts`).
    -   Use `jest` for testing.

## 5. Development Workflow
- **Start Dev**: `yarn run start:dev`
- **Reset DB**: Use `script/create_schema.sql` (can be run via `node script/reset_db.js` if available, or manual SQL execution).

## 6. Memory Distillation System (New)

### 6.1. Concept
To provide long-term memory for the AI, we implement a "Memory Distillation" process. This system extracts atomic facts from conversations and notes, stores them as vector embeddings, and retrieves relevant memories for future interactions.

### 6.2. Architecture
- **Storage**: `semantic_memories` table (PostgreSQL + `pgvector`).
    - **No Foreign Keys**: `source_id` is a UUID, `user_id` is a UUID.
    - **Classification**: Memories are classified as `PERSONAL`, `DOMAIN`, or `TASK`.
    - **Provenance**: `source_type` (`CHAT` | `NOTE`) tracks where the memory came from.
- **Service**: `MemoryService` handles:
    - **Distillation**: Extracting facts via LLM (Analyst Persona).
    - **Deduplication**: Checking against existing vector embeddings before insertion.
    - **Retrieval**: Hybrid search (Vector + Keyword) for RAG.
- **Integration**:
    - **Chat**: `ChatService` retrieves relevant memories during `streamMessage` and injects them into the system prompt.
    - **LLM**: `LlmService` provides `getEmbeddings` (defaulting to `text-embedding-004`).

### 6.3. Distillation Workflow (Planned)
1.  **Trigger**: Topic Shift or Session End.
2.  **Extraction**: LLM identifies "Agreed Facts" vs "Transient Noise".
3.  **Storage**: Facts are stored with an evolving `importance` score.
3.  **Storage**: Facts are stored with an evolving `importance` score.
4.  **Consolidation**: Contradictory new facts update/archive old facts.

### 6.4. Historical Memory Backfill (Auto-Trigger)
-   **Purpose**: Automatically generate memories for old sessions that predate the distillation system.
-   **Mechanism**:
    -   **Trigger**: When a user loads a chat session (`GET /messages`), the system checks metadata.
    -   **Zero-Cost Check**: If `metadata.backfill_complete` is NOT true, a background job is enqueued.
    -   **Worker**: `InMemoryJobQueue` processes the backfill in chunks (20 messages) recursively.
    -   **Checkpointing**: Saves `last_backfilled_message_id` to DB to support crash recovery and idempotency.
    -   **Completion**: Once caught up, `backfill_complete` is set to `true`, preventing future overhead.

### 6.5. Retrieval Pipeline (检索流程)
1.  **Query Analysis**: Analyze user intent.
    -   **意图分析**: 分析用户查询的意图。
2.  **Hybrid Search**: Combine `pgvector` HNSW search with keyword matching.
    -   **混合搜索**: 结合 `pgvector` 的 HNSW 向量搜索与关键词匹配。
3.  **Adaptive Ranking (自适应排序)**: 
    -   **Concept**: Re-ranks candidates based on multiple factors.
    -   **理念**: 基于多重因子对召回的候选集进行重排序。
    -   **Formula (公式)**:
        `FinalScore = (Similarity * 0.7) + (Importance * 0.2) + (Recency * 0.1)`
    -   **Components (分量)**:
        -   **Similarity (相似度)**: Cosine similarity of embeddings.
            -   **余弦相似度**: 向量的点积与模长之比。
            -   **Vector Origins (向量来源)**:
                -   **Vector A (Query)**: Generated in real-time from user input via `llm.getEmbeddings(query)`.
                -   **Vector B (Memory)**: Retrieving from DB `embedding` column (generated at creation time).
            -   **Calculation (计算公式)**: `(A . B) / (||A|| * ||B||)`
        -   **Importance (重要性)**: Normalized score (1-3 → 0.33-1.0).
            -   **归一化重要性**: 将 1-3 分映射到 0.33-1.0 区间。
            -   **Source (来源)**: Generated by LLM during `distillConversation` based on information value (Critical/Valuable/Ordinary).
        -   **Recency (时效性)**: Time decay function `1 / (1 + 0.1 * days)`.
            -   **时间衰减**: 随时间推移降低权重，优先展示近期记忆。

### 6.6. Graph RAG Architecture (Personalized Knowledge Graph)
- **Purpose**: To model entities (Concepts, Projects, Tech) and their relationships, enabling mutli-hop reasoning.
- **Schema**:
    - **`graph_nodes`**: Stores entities with `embedding` (for semantic deduplication) and `type`.
    - **`graph_edges`**: Stores relationships (`source` -> `relation` -> `target`) with weights.
- **Process**:
    1. **Extraction**: `WorkerPoolService` dispatches task to `distillation.processor.ts`, where LLM extracts Entities & Relations.
    2. **Ingestion**: Processor directly connects to DB to Upsert Nodes and Create Edges (idempotent).
    3. **Traversal**: `GraphService` uses **Recursive CTE** (up to 3 hops) to find relevant paths during simple retrieval.
- **Threading Model**:
    -   **Generic Worker Pool**:
        -   **Service**: `WorkerPoolService` wraps `Piscina` for robust concurrency.
        -   **Dispatcher**: `main.worker.ts` routes tasks.
        -   **Processor**: `distillation.processor.ts` contains pure business logic (no worker deps).
    -   **Extraction & Ingestion**: Running strictly in **Worker Threads**.
        -   **Why**: Prevent Node.js Event Loop blocking during heavy graph processing or bulk DB writes.
        -   **Mechanism**: Main thread sends `DB_CONFIG`; Processor initializes independent `DataSource`.
    -   **Retrieval**: Running in **Main Thread** (fast read queries).
