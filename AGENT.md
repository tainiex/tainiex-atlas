# AGENT.md - Project Guide for AI Assistants

This document serves as the authoritative guide for AI agents working on the `tainiex-atlas` project. It outlines the architectural decisions, design patterns, and constraints that must be followed.

## 0. Principle
- You should detect the OS type before using any tools to ensure you use the correct one (PowerShell, Bash, Zsh, etc.).
- Save the plan file and all related data generated by the code agent to the .llm directory.


## 1. Project Overview
- **Project Name**: `tainiex-atlas`
- **Description**: Backend service for the Tainiex platform, providing authentication, chat capabilities, and AI integration.
- **Framework**: NestJS (Node.js)
- **Language**: TypeScript (Target: ES2023)
- **Database**: PostgreSQL (via TypeORM)
- **Package Manager**: Yarn
- **Debug Directory**: Save all debug artifacts (scripts, logs, temp files) to the .llm directory.

## 2. Architecture & Design

### 2.1. Modular Structure
The application follows a modular architecture. Each major feature has its own directory in `src/` containing its Module, Controller, Service, and Entities.

- **`src/app.module.ts`**: Root module, aggregates all feature modules.
- **`src/auth/`**: Authentication logic (Local & Google OAuth).
- **`src/users/`**: User management and persistence.
- **src/chat/**: Chat sessions, message history, conversation logic, and **WebSocket Gateway**.
- **src/llm/**: Integration with Google Vertex AI (Gemini).
- **`src/invitation/`**: Invitation code generation and validation system.
- **`shared-lib/`**: Shared interfaces and DTOs (e.g., `IUser`).
  - Request parameter structs (DTOs)
  - Response structs
  - Common shared structs
  - Keep the API type definitions shared
  - The shared library must contain more comments for users

### 2.2. Database (TypeORM)
- **Entities**: All entities are defined in their respective modules/directories.
- **Naming Convention**:
    - **Class Properties**: `camelCase` (e.g., `createdAt`)
    - **Database Columns**: `snake_case` (e.g., `created_at`)
    - **Constraint**: Always use `@Column({ name: 'snake_case_name' })` to map properties.
- **Sync**: `synchronize: true` is currently enabled for development auto-migration.
- **Schema Script**: `script/create_schema.sql` serves as the reference for the "fresh" database state and seed data.
  - **Seeding**: 100 codes are auto-generated via SQL `generate_series` in `create_schema.sql`.
  - Avoid using foreign keys; it's considered bad practice. Constraints should be handled in the code.
  - If entity schemas are used for frontend responses, they must reside in a shared library. 

### 2.3. Authentication Flow
- **Strategy**: JWT Pair (Access Token + Refresh Token).
- **Tokens**:
    - `access_token`: Short-lived (15m).
    - `refresh_token`: Long-lived (7d), hashed and stored in DB (`hashed_refresh_token`).
- **WebSocket Authentication**: 
    - Supports both manual `auth.token` and browser-based `httpOnly` cookies (`access_token`).
    - The gateway parses the `Cookie` header from the handshake if no token is provided in `auth`.
- **Google OAuth**:
    - **Login**: `POST /auth/google` with `{ code }`.
    - **New User Flow**:
        1. If user doesn't exist, backend returns `{ requiresInvite: true, signupToken: "..." }`.
        2. **Security**: We do NOT return the raw Google ID Token. We issue a temporary, backend-signed `signupToken` containing the user's profile info.
        3. Client submits `signupToken` + `invitationCode` to `POST /auth/google/signup` to finalize creation.

## 3. Key Feature Specifications

### 3.1. Invitation System
- **Mandatory**: New registrations (Email or Google) MUST provide a valid invitation code.
- **Implementation**: `InvitationService` checks code validity, expiry, and usage status.
- **Storage**: `invitation_code` table. Foreign keys to User are NOT used; `usedByUserId` is stored as a raw UUID string.
- **Seeding**: 100 codes are auto-generated via SQL `generate_series` in `create_schema.sql`.

### 3.2. Chat System
- **Sessions**: Stored in `chat_sessions`. Contains a `title` and link to `User`.
- **Messages**: Stored in `chat_messages`. Linked to `ChatSession`.
- **Real-time Streaming**: Implemented via `ChatGateway` using Socket.io. Supports character-by-character streaming to bypass Cloud Run/Proxy buffering.
- **Auto-Title**: Upon the **first message** of a session, the system calls `LlmService` to generate a summary title (< 15 chars) and updates the session title.

### 3.4. Global JWT Configuration
- **Standardization**: `JwtModule` is registered as a **global module** in `AuthModule` via `registerAsync`.
- **Consistency**: All feature modules (like `ChatModule`) must NOT re-register `JwtModule` to ensure they use the same Secret Key and Service instance.

### 3.3. LLM Integration
- **Provider**: Google Vertex AI (Gemini Models).
- **Service**: `LlmService` handles API calls to Vertex AI (both standard `generateContent` and streaming `streamChat`).
- **Configuration**: Credentials loaded via `GSA_KEY_FILE` or explicit Project/Location env vars.

## 4. Constraints & Conventions
1.  **Code Style**: Follow standard Prettier/ESLint rules.
2.  **DTOs/Interfaces**: Define shared interfaces in `shared-lib` when applicable to potential frontend sharing.
3.  **Environment Variables**: All sensitive config (DB creds, API keys) must come from `ConfigService`.
4.  **WebSocket CORS**: Uses a dynamic origin function in `ChatGateway` to support `credentials: true` with wildcard origins (mirrors request origin).
5.  **No Direct SQL**: Prefer TypeORM repositories for data access, unless performing bulk seed/maintenance operations in scripts.
    - When modifying DB schema, always update **both** the Entity file AND `script/create_schema.sql`.
    - When adding new modules, remember to register them in `AppModule`.
    - **Separation of Concerns**: Keep `ChatModule` (Domain/Stateful) and `LlmModule` (Infrastructure/Stateless) separate. `Chat` consumes `Llm`.
    - **LLM Interaction Constraint**: Direct LLM chat interaction is forbidden. All chat interactions MUST be scoped to a `ChatSession` and managed via `ChatModule`.
6.  **Security**:
    -   **CORS**: NEVER use dynamic callbacks that reflect the origin (`callback(null, true)`). Always check against `CORS_ORIGIN`.
    -   **Race Conditions**: Use atomic database operations (e.g., `update` with `where`) for state transitions like claiming codes.
7.  **Testing**:
    -   All business logic (Services/Gateways) MUST have unit tests (`.spec.ts`).
    -   Use `jest` for testing.

## 5. Development Workflow
- **Start Dev**: `yarn run start:dev`
- **Reset DB**: Use `script/create_schema.sql` (can be run via `node script/reset_db.js` if available, or manual SQL execution).
